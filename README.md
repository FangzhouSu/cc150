# 项目简介

算法面试圣经(俗称cc150)《Cracking the Coding Interview: 150 Programming Interview Questions and Solutions》。LeetCode上很多的题目都是来自这本书的。

国内有第五版的翻译[《程序员面试金典 第五版》](http://download.csdn.net/download/ab920322/9029587)。目前已经更新到了第六版。

由于题量由150题增加到189道题([第六版](http://download.csdn.net/download/u011433684/9553267)应该叫cc189了吧)，而且官方给出的是Java版，这整理了第六版的Python实现。

## 使用指南

```bash
# 安装jupyter
pip3 install jupyter

# 进入项目下的jupter目录,启动jupyter服务器.访问地址http://localhost:8888/tree
jupyter notebook
```

## 题目列表

| 序号           | 题目           | 备注  |
| ------------- |----------------| -----|
| 1.1    | [1.1 判断字符串是否有重复的字符](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.1%20判断字符串是否有重复的字符.md) |  |
| 1.2    | [1.2 反转字符串](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.2%20反转字符串.md) |  |
| 1.3    | [1.3 判断两个字符串能否通过重排列变为相同的字符串](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.3%20判断两个字符串能否通过重排列变为相同的字符串.md) |  |
| 1.4    | [1.4 用%20替换掉空格](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.4%20用%2520替换掉空格.md) |  |
| 1.5    | [1.5 字符串压缩](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.5%20字符串压缩.md) |  |
| 1.6    | [1.6 旋转矩阵](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.6%20翻转矩阵.md) |  |
| 1.7    | [1.7 将矩阵中0元素所在行、列清零](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.7%20将矩阵中0元素所在行、列清零.md) | |
| 1.8    | [1.8 判断是否为子字符串](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.8%20判断是否为子字符串.md) |  |
| 1.9    | [1.9 有序数组循环移动，找最小值](https://github.com/panxl6/cc150/blob/master/8.1%20数组和字符串/1.9%20有序数组循环移动，找最小值.md) |  |
| 2.1    | [2.1 移除未排序链表中的重复节点](https://github.com/panxl6/cc150/blob/master/8.2%20链表/2.1%20移除未排序链表中的重复节点.md) |  |
| 2.2    | [2.2 取倒数第K的值](https://github.com/panxl6/cc150/blob/master/8.2%20链表/2.2%20取倒数第K的值.md) |  |
| 2.4    | [2.4 按基准值将链表分为两部分](https://github.com/panxl6/cc150/blob/master/8.2%20链表/2.4%20按基准值将链表分为两部分.md) |  |

## 备注

- 链表节点的定义：
```python
# Definition for singly-linked list.
class ListNode:
    
    def __init__(self, x):
        self.val = x
        self.next = None
```
- 相关的公共放在了`jupyter/common`目录，引入方式如下：
```python
import os
import sys
sys.path.insert(0, os.path.abspath('./common'))
```

## 第六版题目

| 序号           | 题目           | 描述           |
| ------------- |----------------|----------------|
|        | | <h4>数组与字符串<h4> |
| 1.1    | **判定字符是否唯一** | 实现一个算法,确定一个字符串的所有字符是否全都不同。假使不允许使用额外的数据结构,又该如何处理? |
| 1.2    | **判定是否互为字符重排** | 给定两个字符串,请编写程序,确定其中一个字符串的字符重新排列后,能否变成另一个字符串。 |
| 1.3    | **URL 化** | 编写一种方法,将字符串中的空格全部替换为 %20 。假定该字符串尾部有足够的空间存放新增字符,并且知道字符串的“真实”长度。(注:用 Java 实现的话,请使用字符数组实现,以便直接在数组上操作。) <br>*示例*:<br>*输入:* "Mr John Smith", 13 <br>*输出:* "Mr%20John%20Smith" |
| 1.4    | **回文排列**  | 给定一个字符串,编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。<br>*示例:*<br>*输入:* Tact Coa<br>*输出:* True (排列有 "taco cat" 、 "atco cta" ,等等) |
| 1.5    | **一次编辑**  | 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。给定两个字符串,编写一个函数判定它们是否只需要一次(或者零次)编辑。<br>*示例:* <br> pale, ple -> true <br>pales, pale -> true <br>pale, bale -> true <br> pale, bake -> false |
| 1.6    | **字符串压缩**  | 利用字符重复出现的次数,编写一种方法,实现基本的字符串压缩功能。比如,字符串 aabcccccaaa 会变为 a2b1c5a3 。若“压缩”后的字符串没有变短,则返回原先的字符串。你可以假设字符串中只包含大小写英文字母(a 至 z) |
| 1.7    | **旋转矩阵**  | 给定一幅由 N × N 矩阵表示的图像,其中每个像素的大小为 4 字节,编写一种方法,将图像旋转 90 度。不占用额外内存空间能否做到? |
| 1.8    | **零矩阵**  | 编写一种算法,若 M × N 矩阵中某个元素为 0,则将其所在的行与列清零。 |
| 1.9    | **字符串轮转**  | 假定有一种 isSubstring 方法,可检查一个单词是否为其他字符串的子串。给定两个字符串 s1 和 s2 ,请编写代码检查 s2 是否为 s1 旋转而成,要求只能调用一次isSubstring (比如, waterbottle 是 erbottlewat 旋转后的字符串)。 |
|        | | <h4>链表<h4> |
| 2.1    | **移除重复节**  | 编写代码，移除未排序链表中的重复节点。<br> *进阶：*如果不得使用临时缓冲区，该怎么解决？ |
| 2.2    | **返回倒数第k个节点**  | 实现一种算法，找出单向链表中倒数第k 个节点。 |
| 2.3    | **删除中间节点**  | 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。<br> *示例：* <br> *输入：*  单向链表a->b->c->d->e->f 中的节点c <br> *结果：* 不返回任何数据，但该链表变为a->b->d->e->f |
| 2.4    | **分割链表**  | 编写程序以x 为基准分割链表，使得所有小于x 的节点排在大于或等于x 的节点之前。如果链表中包含x，x 只需出现在小于x 的元素之前（如下所示）。分割元素x只需处于“右半部分”即可，其不需要被置于左右两部分之间。<br> 示例：<br>输入：3 -> 5 -> 8-> 5 -> 10 -> 2 -> 1 [分节点为5] <br>输出：3 -> 1 -> 2 -> 10 -> 5-> 5 -> 8 |
| 2.5    | **链表求和**  | 给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。 <br>示例：<br> 输入：(7-> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295 <br>输出：2 -> 1 -> 9，即912 <br> 进阶：假设这些数位是正向存放的，请再做一遍。 <br><br>示例：<br>输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295 <br> 输出：9 -> 1 -> 2，即912|
| 2.6    | **回文链表**  | 编写一个函数，检查链表是否为回文。 |
| 2.7    | **链表相交**  | 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k 个节点与另一个链表的第j 个节点是同一节点（引用完全相同），则这两个链表相交。 |
| 2.8    | **环路检测**  | 给定一个有环链表，实现一个算法返回环路的开头节点。有环链表的定义：在链表中某个节点的next 元素指向在它前面出现过的节点，则表明该链表存在环路。 <br>示例：<br>输入：A -> B -> C -> D -> E -> C（C 节点出现了两次）<br>输出：C|
|  | | <h4>栈和队列<h4> |
| 3.1    | **三合一**  | 描述如何只用一个数组来实现三个栈。 |
| 3.2    | **栈的最小**  | 请设计一个栈，除了pop 与push 函数，还支持min 函数，其可返回栈元素中的最小值。执行push、pop 和min 操作的时间复杂度必须为O(1)。 |
| 3.3    | **堆盘子**  | 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks 应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。<br>进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop 操作。 |
| 3.4    | **化栈为队**  | 实现一个MyQueue 类，该类用两个栈来实现一个队列。 |
| 3.5    | **栈排序**  | 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和isEmpty。 |
| 3.6    | **动物收容所**  | 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog 和dequeueCat。允许使用Java 内置的LinkedList 数据结构。 |
|  | | <h4>树与图<h4> |
| 4.1    | **节点间通路**  | 给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 |
| 4.2    | **最小高度树**  | 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。 |
| 4.3    | **特定深度节点链表**  | 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为D，则会创建出D 个链表） |
| 4.4    | **检查平衡性**  | 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过1。 |
| 4.5    | **合法二叉搜索树**  | 实现一个函数，检查一棵二叉树是否为二叉搜索树。 |
| 4.6    | **后继者**  | 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。可以假定每个节点都含有指向父节点的连接。 |
| 4.7    | **编译顺序**  | 给你一系列项目（projects）和一系列依赖关系（依赖关系dependencies为一个链表，其中每个元素为两个项目的编组，且第二个项目依赖于第一个项目）。所有项目的依赖项必须在该项目被编译前编译。请找出可以使得所有项目顺利编译的顺序。如果没有合法的编译顺序，返回错误。 <br>示例：<br>输入：<br>projects: a, b, c, d, e, f<br>dependencies: (a, d), (f, b), (b, d), (f, a), (d, c)<br>输出：f, e, a, b, d, c |
| 4.8    | **首个共同祖先**  | 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。 |
| 4.9    | **二叉搜索树序列**  | 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉树，输出所有可能生成此树的数组。 |
| 4.10    | **检查子树**  | 你有两棵非常大的二叉树：T1，有几百万个节点；T2，有几百个节点。设计一个算法，判断T2 是否为T1 的子树。<br>如果T1 有这么一个节点n，其子树与T2 一模一样，则T2 为T1 的子树，也就是说，从节点n 处把树砍断，得到的树与T2 完全相同。 |
| 4.11    | **随机节点**  | 你现在要从头开始实现一个二叉树类，该类除了插入（insert）、查找（find）和删除（delete）方法外，需要实现getRandomNode()方法用于返回树中的任意节点。该方法应该以相同的概率选择任意的节点。设计并实现getRandomNode 方法并解释如何实现其他方法。 |
| 4.12    | **求和路径**  | 给定一棵二叉树，其中每个节点都含有一个整数数值（该值或正或负）。设计一个算法，打印节点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下（只能从父节点指向子节点方向）。 |
|  | | <h4>位操作<h4> |
| 5.1    | **插入**  | 给定两个32 位的整数N 与M，以及表示比特位置的i 与j。编写一种方法，将M插入N，使得M从N 的第j 位开始，到第i 位结束。假定从j 位到i 位足以容纳M，也即若M = 10 011，那么j 和i 之间至少可容纳5 个位。例如，不可能出现j = 3 和i = 2 的情况，因为第3 位和第2 位之间放不下M。<br>示例：<br>输入：N = 10000000000, M = 10011, i = 2, j = 6<br>输出：N = 10001001100 |
| 5.2    | **二进制数转字符串**  | 给定一个介于0 和1 之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32 位以内的二进制表示，则打印“ERROR”。 |
| 5.3    | **翻转数位**  | 给定一个整数，你可以将一个数位从0 变为1。请编写一个程序，找出你能够获得的最长的一串1 的长度。<br>示例：<br>输入：1775（或者：11011101111）<br>输出：8 |
| 5.4    | **下一个数**  | 给定一个正整数，找出与其二进制表达式中1 的个数相同且大小最接近的那两个数（一个略大，一个略小）。 |
| 5.5    | **调试**  | 解释代码((n & (n-1)) == 0)的具体含义。 |
| 5.6    | **整数转换**  | 编写一个函数，确定需要改变几个位才能将整数A 转成整数B。<br>示例：<br>输入：29（或者: 11101），15（或者: 01111）<br>输出：2 |
| 5.7    | **配对交换**  | 编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0 与位1 交换，位2 与位3 交换，以此类推）。 |
| 5.8    | **绘制直线**  | 有个单色屏幕存储在一个一维字节数组中，使得8 个连续像素可以存放在一个字节里。屏幕宽度为w，且w 可被8 整除（即一个字节不会分布在两行上），屏幕高度可由数组长度及屏幕宽度推算得出。请实现一个函数，绘制从点(x1, y)到点(x2, y)的水线。该方法的签名应形似于drawLine(byte[] screen, int width, int x1, int x2, int y)。 |
|  | | <h4>数学与逻辑题<h4> |
| 6.1    | **较重的药丸**  | 有20 瓶药丸，其中19 瓶装有1.0 克的药丸，余下1 瓶装有1.1 克的药丸。<br>给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次。 |
| 6.2    | **篮球问题**  | 有个篮球框，下面两种玩法可任选一种。<br>玩法1：一次出手机会，投篮命中得分。<br>玩法2：三次出手机会，必须投中两次。<br>如果p 是某次投篮命中的概率，则p 的值为多少时才会选择玩法1 或玩法2？ |
| 6.3    | **多米诺骨牌**  | 有个8 × 8 棋盘，其中对角的角落上，两个方格被切掉了。给定31 块多米诺骨牌，一块骨牌恰好可以覆盖两个方格。用这31 块骨牌能否盖住整个棋盘？请证明你的答案（提供范例或证明为什么不能）。 |
| 6.4    | **三角形上的蚂蚁**  | 三角形的三个顶点上各有一只蚂蚁。如果蚂蚁开始沿着三角形的边爬行，两只或三只蚂蚁撞在一起的概率有多大？假定每只蚂蚁会随机选一个方向，每个方向被选到的概率相等，而且三只蚂蚁的爬行速度相同。<br>类似问题：在n 个顶点的多边形上有n 只蚂蚁，求出这些蚂蚁发生碰撞的概率。 |
| 6.5    | **水壶问题**  | 有两个水壶，容量分别为3 夸脱①和5 夸脱，若水的供应不限量（但没有量杯），怎么用这两个水壶得到刚好的水？注意，这两个水壶呈不规则状，无法精准地装满“半壶”水。 |
| 6.6    | **蓝眸岛**  | 有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8 点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人有蓝眼睛，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？ |
| 6.7    | **大灾难**  | 在大灾难后的新世界，世界女王非常关心出生率。 因此，她规定所有家庭都必须有一个女孩，否则将面临巨额罚款。如果所有的家庭都遵守这个政策——所有家庭在得到一个女孩之前不断生育，生了女孩之后立即停止生育——那么新一代的性别比例是多少（假设每次怀孕后生男生女的概率是相等的）？通过逻辑推理解决这个问题，然后使用计算机进行模拟。 |
| 6.8    | **扔鸡蛋问题**  | 有栋建筑物高100 层，若从第N 层或更高的楼层扔下来，鸡蛋就会破碎；若从第N 层以下的楼层扔下来则不会破碎。给你两个鸡蛋，请找出N，并要求最差情况下扔鸡蛋的次数为最少。 |
| 6.9    | **100个储物柜**  | 走廊上有100 个关上的储物柜。有个人先是将100 个柜子全都打开。接着，每数两个柜子关上一个。然后，在第三轮时，再每隔两个就切换第三个柜子的开关状态（也就是将关上的柜子打开，将打开的关上）。照此规律反复操作100 次，在第i 轮，这个人会每数i 个就切换第i 个柜子的状态。当第100 轮经过走廊时，只切换第100 个柜子的开关状态，此时有几个柜子是开着的？ |
| 6.10    | **有毒的苏打水**  | 你有1000 瓶苏打水，其中有一瓶有毒。 你有10 条可用于检测毒物的试纸。一滴毒药会使试纸永久变黄。你可以一次性地将任意数量的液滴置于试纸上，你也可以多次重复使用试纸（只要结果是阴性的即可）。 但是，每天只能进行一次测试，用时7 天才可得到测试结果。你如何用尽量少的时间找出哪瓶苏打水有毒？<br>进阶：编写程序模拟你的方法。 |
|  | | <h4>面向对象设计<h4> |
|  | | <h4>递归与动态规划<h4> |
|  | | <h4>系统设计与可扩展性<h4> |
|  | | <h4>排序与查找<h4> |
|  | | <h4>测试<h4> |
|  | | <h4>C和C++<h4> |
|  | | <h4>Java<h4> |
|  | | <h4>数据库<h4> |
|  | | <h4>线程与锁<h4> |
|  | | <h4>中等难题<h4> |
|  | | <h4>高难度题<h4> |

## 计划表

- [x] 统一代码格式
- [ ] 美化文字格式，提升阅读体验
- [ ] 增加LeetCode的相关专题
- [ ] 完成后续的章节
- [ ] 增加示意图或动画
- [ ] 增加第六版的内容
- [ ] 对比官方的Java版答案，校验一次
- [ ] 抽象测试用例运行框架，实现一个Online judge
