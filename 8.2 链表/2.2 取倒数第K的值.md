## 题目
实现一个算法，找出单向链表中倒数第k个节点。

## 注解



```python
# coding=utf-8

# Definition for singly-linked list.
class ListNode:
    
    def __init__(self, x):
        self.val = x
        self.next = None


class LinkList:
    
    # 根据列表创建单链表
    def get_list(self, data):
        if len(data) == 0:
            return None
        
        temp = head = ListNode(data[0])
        for i in range(1, len(data)):
            temp.next = ListNode(data[i])
            temp = temp.next
        
        return head
    
    # 逐个输出链表的内容
    def print_list(self, head):
        if head is None:
            return
        
        while head is not None:
            print(head.val)
            head = head.next
        
        
class Solution:
    
    def find_last_k_num(self, head, k):
        if head is None:
            return None
        
        counter = 0
        slow = fast = head
        while counter < k and fast is not None:
            fast = fast.next
            counter += 1
        
        # k比链表的长度还大
        if counter < k and fast is None:
            return None

        while fast is not None:
            fast = fast.next
            slow = slow.next
        
        return slow
    

test_case = [
    # 注意，k从１开始计数
    # [链表内容, k值, 链表中第k个节点的值]
    
    # 测试空值异常
    [[], 0, None],
    
    # k值异常
    [[1, 2], 3, None],
    
    # 只有一个元素
    [[6], 1, 6],
    
    # 正常情况
    [[6, 7, 10, 4, 5], 3, 10]
]


def run_test():
    solution = Solution()
    linklist = LinkList()
    
    for item in test_case:
        head = linklist.get_list(item[0])
        target = solution.find_last_k_num(head, item[1])
        if target is None:
            if target == item[2]:
                print('通过')
            else:
                print('不通过')
        else:
            if target.val == item[2]:
                print('通过')
            else:
                print('不通过')
            
if __name__ == '__main__':
    run_test()
```

    通过
    通过
    通过
    通过

